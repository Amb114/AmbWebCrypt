<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta charset="UTF-8">
    <link rel="manifest" href="manifest.json">
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="icon-192.png">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>AmbWebCrypt (pd5c)</title>
    <style>
:root {
    --primary: #00ff41; 
    --warn: #ff9100; 
    --danger: #ff4444; 
    --bg: #111; 
    --panel: #0a0a0a; 
    --text: #d1d1d1; 
}
* {box-sizing: border-box; margin: 0; padding: 0; }

body {font-family: Consolas, monospace;background: var(--bg);color: var(--text);padding: 10px; /* æ‰‹æœºç«¯å¤–è¾¹è·å‡åŠ */line-height: 1.5;}
.container {max-width:900px; margin: 0 auto;border:1px solid #333;padding:15px;/*å†…éƒ¨è¾¹è·å‡å°ï¼Œé‡Šæ”¾æ›´å¤šç©ºé—´*/background: var(--panel); box-shadow: 0 0 20px rgba(0,0,0,0.5);}
/* é’ˆå¯¹æ‰‹æœºç«¯çš„ä¼˜åŒ–ï¼šå½»åº•å»æ‰å¤šä½™è¾¹æ¡† */
@media (max-width: 600px) {body{padding:5px;}
.container{padding:10px;border: none;}/*æ‰‹æœºç«¯å»æ‰å¤§è¾¹æ¡†*/.opt-group {padding:8px;}}

.tabs {display:flex;margin:15px 0;border:1px solid #333;border-radius:4px;overflow: hidden; }
.tab-btn {flex: 1; 
    padding: 12px 5px; 
    background: #1a1a1a; 
    border: none; 
    color: #999; 
    cursor: pointer; 
    font-family: inherit; 
    font-size: 14px;
    white-space: nowrap;
}
.tab-btn.active {background: var(--primary); color: #000; }

.tab-content {display: none; }
.tab-content.active {display: block; }

.input-group {margin: 15px 0; }
label {display: block; margin-bottom: 8px; color: var(--warn); font-size: 0.9rem; }

textarea, input[type="text"], input[type="number"], select {
    width: 100%; 
    background: #222; 
    border: 1px solid #444; 
    color: #fff; 
    padding: 10px; 
    font-family: inherit; 
}

button {
    padding: 10px 20px; 
    background: var(--primary); 
    color: #000; 
    border: none; 
    font-weight: bold; 
    cursor: pointer; 
    margin-top: 10px; 
}

.btn-secondary {background: #333; color: #fff; border: 1px solid #444; }
button:disabled { background: #666 !important; color: #999 !important; cursor: not-allowed !important; }
.opt-group {
    margin: 15px 0; 
    padding: 12px; 
    background: #161616; 
    border: 1px solid #333; 
    border-radius: 4px;
}

.res-textarea {
    height: 180px; 
    background: #000; 
    color: var(--primary); 
    border: 1px solid var(--primary); 
    font-size: 13px; 
}

.identity-badge {
    margin: 10px 0; 
    padding: 8px; 
    background: #000; 
    text-align: center; 
    font-size: 0.9rem;
}

.drop-hint {
    position: fixed; /* å¿…é¡»æ˜¯ fixedï¼Œæ‰èƒ½æ‚¬æµ®åœ¨ç½‘é¡µä¹‹ä¸Šè€Œä¸å ä½ */
    top: 0; left: 0; right: 0; bottom: 0; 
    background: rgba(0, 255, 65, 0.2); /* æ·¡æ·¡çš„ç»¿è‰²é®ç½© */
    border: 4px dashed var(--primary); 
    display: none; /* é»˜è®¤å¿…é¡»éšè— */
    align-items: center; 
    justify-content: center; 
    font-size: 2rem; 
    color: var(--primary); 
    z-index: 9999; /* ç¡®ä¿åœ¨æœ€ä¸Šå±‚ */
    pointer-events: none; /* ç¡®ä¿ä¸å¹²æ‰°é¼ æ ‡ç‚¹å‡» */
}

.drop-hint.show {
    display: flex; /* åªæœ‰åœ¨æ‹–æ‹½æ–‡ä»¶è¿›å…¥æ—¶æ‰æ˜¾ç¤º */
}
</style>
<link id="via_inject_css_blocker" type="text/css" rel="stylesheet" href="https://j.157126.xyz/via_inject_blocker.css"><style type="text/css" id="__via_marker__"></style></head>
<body>
<!-- è‡ªåŠ¨å¤„ç†å…¨å±ç•Œé¢ -->
<div id="loader-screen" style="display:none; max-width: 600px; margin: 30px auto; padding: 20px; background: #0a0a0a; border: 1px solid #333; color: #fff; font-family: Consolas, monospace; border-radius: 8px;">
<!-- ä¿®å¤åï¼ˆç›´æ¥æ›¿æ¢loader-screenå†…çš„æ ‡é¢˜åŒºåŸŸï¼‰ -->
<div style="display: flex; justify-content: space-between; align-items: center; gap: 10px; margin-bottom: 10px;">
    <h1 style="font-size: clamp(16px, 5vw, 22px); white-space: nowrap; margin: 0; color: var(--primary); border: none; padding: 0;">ğŸ”¤ AmbWebCrypt (pd5c)</h1>
    <button onclick="backupTool()" style="background: none; border: 1px solid #444; color: #888; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 11px; flex-shrink: 0; white-space: nowrap; margin: 0;">
        ğŸ’¾ ä¿å­˜æœ¬é¡µ
    </button>
</div>
<div style="font-size: clamp(14px, 3vw, 16px); color: var(--warn); font-weight: bold; text-align: center; margin-bottom: 20px;">
    ğŸ‰ 2026æ–°å¹´å¿«ä¹ ğŸ‰
</div>

    <!-- æ­¥éª¤ 1 & 2 ä¿æŒä¸å˜... -->
    <div id="step1-box" style="margin-bottom: 20px;">
        <div id="step1-status" style="color: var(--warn); font-weight: bold;">(è¿›è¡Œä¸­) 1.ä¸‹è½½åŸå§‹æ•°æ®æµ</div>
        <div id="progress-container" style="display: none; height: 10px; background: #222; border: 1px solid #444; margin: 10px 0; border-radius: 5px; overflow: hidden;">
            <div id="step1-fill" style="height: 100%; background: var(--primary); width: 0%;"></div>
        </div>
        <div id="step1-stats" style="font-size: 0.85rem; color: #aaa; margin-top: 5px;">å‡†å¤‡ä¸­...</div>
    </div>

    <div id="step2-box" style="margin-bottom: 20px;">
        <div id="step2-status" style="color: #444; font-weight: bold;">(ç­‰å¾…ä¸­) 2. è§£å¯†æ•°æ®</div>
        <div style="height: 4px; background: #222; margin-top: 8px; border-radius: 2px; overflow: hidden;">
            <div id="step2-fill" style="height: 100%; background: var(--primary); width: 0%;"></div>
        </div>
    </div>

    <!-- æ­¥éª¤ 3: è§¦å‘ä¸‹è½½ -->
    <div id="step3-box" style="margin-bottom: 20px;">
        <div id="step3-status" style="color: #444; font-weight: bold;">(ç­‰å¾…ä¸­) 3. è§¦å‘ä¸‹è½½</div>
        <p style="font-size: 0.8rem; color: #666; margin: 10px 0 8px 0;">è‹¥æµè§ˆå™¨æœªè‡ªåŠ¨ä¸‹è½½ï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ï¼š</p>
        <button id="manual-dl-btn" disabled="" onclick="dlDec()" style="width: 100%; padding: 12px; background: #333; color: #666; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; font-family: inherit;">
            ğŸ’¾ ä¸‹è½½è§£å¯†åæ–‡ä»¶
        </button>
        <div id="loader-warning-msg" style="display:none; color:orange; margin-bottom: 10px; padding: 5px; border: 1px solid orange; background-color: #332b00; border-radius: 3px;"></div>
    </div>

    <!-- æ–°å¢ï¼šè‡ªåŠ¨ä¸‹è½½ç•Œé¢çš„ç»“æœé¢„è§ˆåŒº -->
    <div id="loader-result" style="display:none; border-top: 1px solid #333; padding-top: 15px; margin-top: 15px;">
        <div id="loader-identity" style="margin-bottom: 10px; font-size: 0.9rem;"></div>
        <div id="loader-stats" style="font-size: 0.8rem; color: #888; margin-bottom: 10px;"></div>
        
        <!-- åª’ä½“é¢„è§ˆ -->
        <div id="loader-preview-img" style="display:none; text-align:center; background:#000; padding:10px; border:1px solid #222;">
            <div id="loader-img"></div>
        </div>
        
        <!-- æ–‡æœ¬é¢„è§ˆ -->
        <div id="loader-preview-txt" style="display:none;">
            <textarea id="loader-txt-area" readonly="" style="width:100%; height:200px; background:#000; color:#fff; border:1px solid #444; font-family:inherit; padding:10px; font-size:12px;"></textarea>
        </div>
    </div>
</div>
<div class="drop-hint" id="drop-hint">ğŸ“ é‡Šæ”¾æ–‡ä»¶ä»¥å¯¼å…¥</div>

<!-- æ›¿æ¢ä¸ºä¸‹æ–¹å¸¦æœ‰ id çš„ç‰ˆæœ¬ -->
<div id="header-area" style="display: flex; flex-direction: column; gap: 8px; border-bottom: 2px solid var(--primary); margin-bottom: 20px; padding-bottom: 10px;">
    <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
        <h1 style="font-size: clamp(16px, 5vw, 22px); white-space: nowrap; margin: 0; color: var(--primary); border: none; padding: 0;">ğŸ”¤ AmbWebCrypt (pd5c)</h1>
        <button onclick="backupTool()" style="background: none; border: 1px solid #444; color: #888; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 11px; flex-shrink: 0; white-space: nowrap; margin: 0;">
            ğŸ’¾ ä¿å­˜æœ¬é¡µ
        </button>
    </div>
    <div style="font-size: clamp(14px, 3vw, 16px); color: var(--warn); font-weight: bold; text-align: center;">
        ğŸ‰ 2026æ–°å¹´å¿«ä¹ ğŸ‰
    </div>
</div>

<div id="dec-warning-msg" style="display:none; color:orange; margin-bottom: 10px; padding: 5px; border: 1px solid orange; background-color: #332b00; border-radius: 3px;"></div>
    <!-- æ ‡ç­¾åˆ‡æ¢æ  -->
    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('encode')">ğŸ”¢ åŠ å¯†</button>
        <button class="tab-btn" onclick="switchTab('decode')">ğŸ”¤ è§£å¯†</button>
        <button class="tab-btn" onclick="switchTab('keygen')">ğŸ”‘ å¯†é’¥ç”Ÿæˆ</button>
    </div>

    <!-- 1. ç¼–ç é¢æ¿ -->
    <div id="encode-tab" class="tab-content active">
<!-- æ›¿æ¢åŠ å¯†é¢æ¿çš„â€œé€‰æ‹©æ–‡ä»¶â€åŒºåŸŸ -->
<div class="input-group">
    <label>1. å†…å®¹å½•å…¥</label>
    <textarea id="encode-text" placeholder="åœ¨æ­¤è¾“å…¥æ–‡å­—..." style="height: 300px;"></textarea>
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <!-- å…³é”®ï¼šlabelçš„forå±æ€§ä¸inputçš„idç»‘å®šï¼Œç¡®ä¿ç‚¹å‡»æ ‡ç­¾è§¦å‘è¾“å…¥æ¡† -->
        <label for="encode-file-input" class="file-btn" style="margin: 0; flex: 1; text-align: center; background: #333; border: 1px solid #444; padding: 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 5px; color: #fff; font-weight: bold; border-radius: 4px;">
            ğŸ“ é€‰æ‹©æ–‡ä»¶
        </label>
        <!-- éšè—çš„æ–‡ä»¶è¾“å…¥æ¡†ï¼Œidå¿…é¡»ä¸labelçš„forä¸€è‡´ -->
        <input type="file" id="encode-file-input" style="display:none" onchange="handleFile(this.files[0], 'encode')">
        <button class="btn-secondary" onclick="clearAll('encode')" style="margin: 0; flex: 1; display: flex; align-items: center; justify-content: center; gap: 5px; height: 44px; border-radius: 4px;">
            ğŸ§¹ æ¸…ç©º
        </button>
    </div>
    <div class="file-info" id="e-file-info" style="display: none;"></div>
</div>
<div class="opt-group">
<label style="color:var(--warn); margin-bottom:12px">2. å‹ç¼©ä¸åŠ å¯†è®¾ç½®</label>
    <div style="margin-bottom: 15px;">
        <label style="display:inline-block; white-space:nowrap; margin-right:15px; cursor:pointer">
            <input type="checkbox" id="gzip-enable" checked=""> å¯ç”¨ Gzip å‹ç¼©
        </label>
        <label style="display:inline-block; white-space:nowrap; cursor:pointer">
            <input type="checkbox" id="img-comp" checked="" onchange="reprocImg()"> å›¾åƒé¢„å¤„ç†
        </label>
    </div>

<!-- ç¼©æ”¾æ¨¡å¼ï¼šé€šè¿‡ gap æ§åˆ¶é—´è·ï¼Œrow-gap æ§åˆ¶æŠ˜è¡Œåçš„è¡Œé—´è· -->
<div style="margin-bottom: 10px; display: flex; flex-wrap: wrap; align-items: center; column-gap: 10px; row-gap: 5px;">
    <span style="font-size:0.85rem; color:#aaa; white-space:nowrap;">ç¼©æ”¾æ¨¡å¼:</span>
    <label style="white-space:nowrap; cursor:pointer; display: flex; align-items: center; gap: 3px;"><input type="radio" name="rmode" value="pixel" checked="" onclick="handleModeChange(true, 5)"> åƒç´ </label>
    <label style="white-space:nowrap; cursor:pointer; display: flex; align-items: center; gap: 3px;"><input type="radio" name="rmode" value="short" onclick="handleModeChange(true, 240)"> çŸ­è¾¹</label>
    <label style="white-space:nowrap; cursor:pointer; display: flex; align-items: center; gap: 3px;"><input type="radio" name="rmode" value="long" onclick="handleModeChange(true, 640)"> é•¿è¾¹</label>
    <label style="white-space:nowrap; cursor:pointer; display: flex; align-items: center; gap: 3px;"><input type="radio" name="rmode" value="orig" onclick="handleModeChange(true, 100)"> åŸå›¾</label>
</div>

<!-- æ•°å€¼ä¸è´¨é‡ -->
<div style="margin-bottom: 15px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
    <span id="val-input-wrap" style="display: flex; align-items: center;">
        æ•°å€¼: <input type="number" id="img-val" step="0.1" value="5" style="width:65px; padding:5px; margin:0 3px; background:#222; border:1px solid #444; color:#fff;text-align: center;">
        <span id="unit-text" style="font-size:0.85rem; color:#aaa;">ä¸‡</span>
    </span>
    <span style="display: flex; align-items: center;">
        è´¨é‡: <input type="number" id="img-q" value="30" style="width:42px; padding:5px; margin:0 3px; background:#222; border:1px solid #444; color:#fff;text-align: center;">%
    </span>
    <button class="btn-secondary" onclick="reprocImg()" style="padding:4px 8px; font-size:12px; margin:0; flex-shrink:0;">ğŸ”„ åˆ·æ–°é¢„è§ˆ</button>
</div>
<div style="margin-bottom: 15px; border: 1px dashed #444; padding: 8px; border-radius: 4px; display: flex; flex-wrap: wrap; align-items: center; column-gap: 12px; row-gap: 8px;">
    <span style="font-size:0.85rem; color:#aaa; white-space:nowrap;">åŠ å¯†ç®—æ³•:</span>
    <label style="display: inline-flex; align-items: center; white-space:nowrap; cursor:pointer; gap: 4px;">
        <input type="radio" name="algo" value="0" onchange="checkEncIdentity()"> CBC
    </label>
    <label style="display: inline-flex; align-items: center; white-space:nowrap; cursor:pointer; gap: 4px;">
        <input type="radio" name="algo" value="1" checked="" onchange="checkEncIdentity()"> GCM
    </label>
    <label style="display: inline-flex; align-items: center; white-space:nowrap; cursor:pointer; gap: 4px;">
        <input type="radio" name="algo" value="2" onchange="checkEncIdentity()"> P384
    </label>
    <label style="display: inline-flex; align-items: center; white-space:nowrap; cursor:pointer; gap: 4px;">
        <input type="radio" name="algo" value="3" onchange="checkEncIdentity()"> ED25519ï¼ˆä»…æ”¯æŒç§é’¥ç­¾åã€‚æ•°æ®ä¸ä¼šåŠ å¯†ï¼ï¼‰
    </label>
</div>
<!-- å¯†é’¥è¾“å…¥æ¡† -->
<input type="text" id="e-key" oninput="checkEncIdentity()" class="pwd-input" placeholder="åŠ å¯†å¯†é’¥ (P384å¡«å…¬é’¥ED25519å¡«ç§é’¥)">

<!-- æ–°å¢ï¼šèº«ä»½è¯†åˆ«æç¤ºè¡Œ -->
<div id="enc-identity-msg" style="font-size: 0.8rem; margin-top: 5px; min-height: 1.2em; padding-left: 5px;"></div>
        <!-- ç¼–ç æ‰§è¡ŒæŒ‰é’®ï¼ˆåœ¨é¢æ¿å†…ï¼‰ -->
        <button id="btn-do-encode">ğŸš€ æ‰§è¡Œç¼–ç </button>

        <div class="result" id="e-result" style="display: none;">
            <div class="size-info" id="e-stats"></div>
            <textarea id="res-show-area" class="res-textarea" readonly=""></textarea>
            <div style="margin-top:10px">
                <button onclick="copyRes()">ğŸ“‹ å¤åˆ¶å…¨é‡ç¼–ç </button>
                <button onclick="dlRes('txt')" class="btn-secondary">ğŸ“„ ä¸‹è½½TXT</button>
                <button onclick="dlRes('bin')" class="btn-secondary">ğŸ“¦ ä¸‹è½½BIN</button>
            </div>
        </div>
    </div>
</div>
    <!-- 2. è§£ç é¢æ¿ -->
    <div id="decode-tab" class="tab-content">
        <div class="input-group">
            <label>1. ç¼–ç å½•å…¥ (æ”¯æŒæ‹–å…¥æ–‡ä»¶)</label>
<textarea id="decode-input" placeholder="ç²˜è´´ç¼–ç æ–‡å­—..." style="height: 160px;" oninput="syncBinCheckbox()"></textarea>
<div style="display: flex !important; flex-direction: row; gap: 10px; margin-top: 10px; width: 100%;">
    <label class="file-btn" style="margin: 0; flex: 1; text-align: center; background: #333; border: 1px solid #444; padding: 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 5px; color: #fff; font-weight: bold; border-radius: 4px; white-space: nowrap;">
        ğŸ“ é€‰æ‹©æ–‡ä»¶ <input type="file" style="display:none" onchange="handleFile(this.files[0], 'decode')">
    </label>
    <button class="btn-secondary" onclick="clearAll('decode')" style="margin: 0; flex: 1; display: flex; align-items: center; justify-content: center; gap: 5px; height: 46px; border-radius: 4px; white-space: nowrap; width: auto;">
        ğŸ§¹ æ¸…ç©º
    </button>
</div>
            <div class="file-info" id="d-file-info" style="display: none;"></div>
<div style="margin: 15px 0 10px 0;">
    <label style="cursor:pointer; font-size: 0.85rem; display: flex; align-items: center; gap: 8px; color: #fff;">
        <input type="checkbox" id="is-bin" style="margin:0;"> å¯¼å…¥çš„æ–‡ä»¶æ˜¯äºŒè¿›åˆ¶ (.bin)
    </label>
</div>
        </div>

        <div class="opt-group">
            <label style="color:var(--warn)">2. è§£å¯†è®¾ç½®</label>
            <input type="text" id="d-key" class="pwd-input" placeholder="è§£å¯†å¯†é’¥ (P384å¡«ç§é’¥ED25519å¡«å…¬é’¥)">
        </div>

<div style="display: flex; align-items: center; flex-wrap: wrap; gap: 15px; margin-top: 10px;">
<!-- ç»Ÿä¸€æ ·å¼çš„è¿˜åŸæŒ‰é’®ä¸èº«ä»½æç¤º -->
<div style="display: flex; align-items: center; flex-wrap: wrap; gap: 10px; margin-top: 10px;">
<button id="btn-do-decode" onclick="doDecode()">ğŸ”“ æ‰§è¡Œè¿˜åŸ</button>
    <!-- èº«ä»½æç¤ºæ”¾åœ¨æŒ‰é’®å³è¾¹ï¼Œç©ºé—´ä¸è¶³è‡ªåŠ¨æ¢è¡Œ -->
    <span id="dec-identity-msg" style="font-size: 0.85rem; line-height: 1.4; color: #aaa;"></span>
</div>
</div>
<div class="result" id="d-result" style="display: none;">
    <div style="margin-bottom:15px; border-bottom:1px solid #333; padding-bottom:15px">
        <button onclick="dlDec()">ğŸ’¾ ä¸‹è½½è¿˜åŸæ–‡ä»¶</button>
        <span class="size-info" id="d-stats" style="margin-left:15px"></span>
    </div>
    <div id="d-preview-img" class="preview-area" style="display:none"><label>ğŸ–¼ï¸ åª’ä½“é¢„è§ˆ</label><div id="d-img"></div></div>
    <div id="d-preview-txt" class="preview-area" style="display:none">
        <label>ğŸ“ æ–‡æœ¬å†…å®¹ (ä¸Šé™100K):</label>
        <textarea id="d-txt-area" class="res-textarea" style="height:300px; color:#fff; border-color:#444"></textarea>
    </div>
</div>
</div>
<div id="keygen-tab" class="tab-content">
    <div class="input-group">
        <label>ğŸ” å¯†é’¥å¯¹ç®¡ç†</label>
        <div class="opt-group" style="background:#111; margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="color: var(--warn); margin: 0; font-size: 1rem;">éå¯¹ç§°åŠ å¯†å¯†é’¥ (P-384)</h3>
                <button onclick="generateP384Keys()" style="background:var(--warn); color:#000; margin:0; padding: 6px 12px; font-weight: bold;">ğŸ”„ åˆ·æ–°/ç”Ÿæˆ</button>
            </div>
            <div id="p384-identity-info" class="identity-badge" style="margin-bottom: 10px;"></div>
            <p style="font-size: 0.85rem; color: #aaa; margin-bottom: 10px;">
                <b style="color:var(--danger);">ç§é’¥</b> ç”¨äºè§£å¯†æ‚¨æ”¶åˆ°çš„ä¿¡æ¯ã€‚
                <br><b style="color:var(--primary);">å…¬é’¥</b> å‘ç»™å¯¹æ–¹ï¼Œè®©ä»–ä»¬ç”¨æ­¤å…¬é’¥åŠ å¯†ä¿¡æ¯ç»™æ‚¨ã€‚
            </p>
            
            <label style="color:var(--danger)">ç§é’¥ (Private Key) - ä¸¥ç¦æ³„éœ²</label>
            <div style="display:flex; gap:10px; margin-bottom:15px">
                <input type="text" id="p384-priv-key-display" readonly="" placeholder="å°šæœªç”Ÿæˆ..." style="font-size:11px; flex:1; background:#000; border-color:#444; color:#fff; padding:10px">
                <button onclick="copyKey('p384-priv-key-display')" class="btn-secondary" style="margin:0; padding:0 15px; flex-shrink:0">ğŸ“‹ å¤åˆ¶</button>
            </div>
            
            <label style="color:var(--primary)">å…¬é’¥ (Public Key) - å‘ç»™å¯¹æ–¹</label>
            <div style="display:flex; gap:10px">
                <input type="text" id="p384-pub-key-display" readonly="" placeholder="å°šæœªç”Ÿæˆ..." style="font-size:11px; flex:1; background:#000; border-color:#444; color:#fff; padding:10px">
                <button onclick="copyKey('p384-pub-key-display')" class="btn-secondary" style="margin:0; padding:0 15px; flex-shrink:0">ğŸ“‹ å¤åˆ¶</button>
            </div>
        </div>

        <!-- Ed25519 èº«ä»½è®¤è¯å¯†é’¥åŒºåŸŸ -->
        <div class="opt-group" style="background:#111;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="color: var(--warn); margin: 0; font-size: 1rem;">èº«ä»½è®¤è¯å¯†é’¥ (Ed25519)</h3>
                <button onclick="generateEd25519Keys()" style="background:var(--warn); color:#000; margin:0; padding: 6px 12px; font-weight: bold;">ğŸ”„ åˆ·æ–°/ç”Ÿæˆ</button>
            </div>
            <div id="ed25519-identity-info" class="identity-badge" style="margin-bottom: 10px;"></div>
            <p style="font-size: 0.85rem; color: #aaa; margin-bottom: 10px;">
                <b style="color:var(--danger);">ç§é’¥</b> ç”¨äºå¯¹æ‚¨å‘é€çš„ä¿¡æ¯è¿›è¡Œç­¾åï¼Œè¯æ˜ä¿¡æ¯æ¥æºã€‚
                <br><b style="color:var(--primary);">å…¬é’¥</b> å‘ç»™å¯¹æ–¹ï¼Œè®©ä»–ä»¬ç”¨æ­¤å…¬é’¥éªŒè¯æ‚¨ç­¾åçš„ä¿¡æ¯ã€‚
            </p>

            <label style="color:var(--danger)">ç§é’¥ (Private Key) - ä¸¥ç¦æ³„éœ²</label>
            <div style="display:flex; gap:10px; margin-bottom:15px">
                <input type="text" id="ed25519-priv-key-display" readonly="" placeholder="å°šæœªç”Ÿæˆ..." style="font-size:11px; flex:1; background:#000; border-color:#444; color:#fff; padding:10px">
                <button onclick="copyKey('ed25519-priv-key-display')" class="btn-secondary" style="margin:0; padding:0 15px; flex-shrink:0">ğŸ“‹ å¤åˆ¶</button>
            </div>
            
            <label style="color:var(--primary)">å…¬é’¥ (Public Key) - å‘ç»™å¯¹æ–¹</label>
            <div style="display:flex; gap:10px">
                <input type="text" id="ed25519-pub-key-display" readonly="" placeholder="å°šæœªç”Ÿæˆ..." style="font-size:11px; flex:1; background:#000; border-color:#444; color:#fff; padding:10px">
                <button onclick="copyKey('ed25519-pub-key-display')" class="btn-secondary" style="margin:0; padding:0 15px; flex-shrink:0">ğŸ“‹ å¤åˆ¶</button>
            </div>
        </div>
    </div>
</div>
<!-- æ—¥å¿—æ˜¾ç¤ºåŒº -->
<div class="log" id="log" style="display: none;"></div>

    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script>
    const VER = "pd5c"; // å‡çº§åˆ° pd5c
    const PLIM = 100000; 
    const MAX_PIXELS = 10000000; 
    const MAP = "é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åä¸ªç™¾åƒä¸‡æœå¤šæ¥ç±³å‘é”æ‹‰ç³»éª‡å¤æä½ æ­ªå®ƒä»–å¥¹å•Šæ³¢æ¬¡çš„é¥¿æ­Œå–ä»¥å‡ å¯äº†ä»¬å‘¢å–”å±ç¾¤äººæ˜¯çƒ«é±¼ç»¿å†™ç”¨è¿™è±æ–¹å½•é¹¿å¢å‡¹æŠ˜å±±è‘±ä»ªå‚é•¿ç§§åŒè‰æœ«éŸ³èœé…¸æ±¤åå£çªå¡«ç”°åœŸæœ¨ç«æ°´é‡‘é£é›¨çŸ³ç«¹é¸Ÿé©¬ç‰›ç¾Šè™«èŠ±æ ‘äº‘é›·é›ªæ˜Ÿå…‰å¤©æµ·æ¹–æ—ç‚¹çº¿é¢ä½“æ¡çŒ«ç‹—æœåº“ç‚®è¿›åŸç®¡é”šæ³¡æŠ›åˆ¨è¢å›¾å¦‚ååŠ é”®å‡è‚¥ä¹˜å‡ºé™¤å¤„åˆå¨æ¥šä¹”æ©å¥–æ±Ÿå§œé…±çŠŸåƒµè€³å„¿æ–‡é™ç½‘çƒ­å¡ç©ºè™šæ‹Ÿæƒ³å¸Œä¸å…‹é—¨ä»˜æ¬¾å•¦æ”¾å¤§å“¦æ‰©å¯¹çš®è‚¤çœ‹å¿«æ‰‹å†…å­˜æˆç»©å·®ç™»è®°æœºå£°ç¬¬é›†å¹³æ—¶éƒ½è§‰å¾—å°±è¡Œæ‰“å‡»å“’è¥¿åˆ°å“ªå’³å—½å¸¦é£è¾›è‹¦è€è¯•æ€•æ¼åˆ·æœªå¾®ä½å°ä¼—ä¸­ä»èªä¿¡æ–°æ—§æ¨æ ·é˜³ææ¸…é’é…’æµç•™ç‰©é‡Œä¾‹ç†åŠ›ä¸½ç¤¼æç«‹äº‹å²è§†ç‡å½¢ä¹‹åªæŸ“ç„¶ä¼¼é˜²é‡é¥­æ´—å¤´è¿å«æ‰£å®œ";
    const HEX_MAP = "å“ˆå˜¿å˜»å’•å±å§å“”å˜šå˜›å˜å˜å˜Ÿå•¸å˜¶åš·å™—";
    const B2C = MAP.split(''), C2B = Object.fromEntries(B2C.map((c,i)=>[c,i]));
    const ADMIN_P384_PUB_HEX = "047562a86fcd211fad72ef66958a1d6e9c2d05d749de8e1bad3a522460270dd9be619fdd78ab4a9e3ae3a60cc41cee5f7a2a6d16e93d28465fe80b341dd9518414466dd7c7fd5ae6395d1a8bd58504d24c5e3339f7494bbc4d4aa022726fb479d3"
    const $ = id => document.getElementById(id);
// è¾…åŠ©å·¥å…·ï¼šHexä¸Bufferè½¬æ¢
const hexToBuf = hex => {
    try {
        const clean = hex.trim();
        if (clean.length % 2 !== 0) return null;
        return new Uint8Array(clean.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
    } catch(e) {return null; }
};
const bufToHex = buf => Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
const CryptoUtils = {
    // ç»Ÿä¸€ä½¿ç”¨ SHA-256 çš„ç¬¬ 129-144 bit (å­—èŠ‚ç´¢å¼• 16, 17)
    getShaChecksum: async (data) => {
        const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
        const h = new Uint8Array(hashBuffer);
        return (h[16] << 8) | h[17];
    }
};
// --- å…¨å±€çŠ¶æ€ ---
let eData = null, oFile = null, dData = null;
let decodeRawBuffer = null; 
let decodeFileName = ""; 
let resHeader = "";      
let resTxt = "", resBin = null;
let currentPreviewUrl = null; // å¿…é¡»åŠ ä¸Šè¿™ä¸€è¡Œï¼Œç”¨äºå†…å­˜é‡Šæ”¾
let isEncDataReady = false; // æ˜¾å¼å£°æ˜åŠ å¯†å°±ç»ªçŠ¶æ€

function formatTime(s) {
    if (s <= 0 || !isFinite(s)) return "00:00";
    const f = (v) => Math.floor(v).toString().padStart(2, '0');
    if (s < 3600) return `${f(s/60)}:${f(s%60)}`;
    if (s < 86400) return `${f(s/3600)}:${f((s%3600)/60)}:${f(s%60)}`;
    const d = Math.floor(s/86400);
    return `${d}å¤©${f((s%86400)/3600)}:${f((s%3600)/60)}:${f(s%60)}`;
}
function getAutoExtension(bin) {
    if (!bin || bin.length < 4) return '';
    const h = Array.from(bin.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join('');
    if (h.startsWith('1a45dfa3')) return '.mkv';
    if (h.startsWith('28b52ffd')) return '.zst'; 
    if (h.startsWith('04224d18')) return '.lz4';
    if (h.startsWith('1f8b08000000')) return '.gz';
    if (h.startsWith('377abcaf271c')) return '.7z';
    if (h.startsWith('504b0304')) return '.zip';
    if (h.startsWith('89504e47')) return '.png';
    if (h.startsWith('ffd8ff')) return '.jpg';
    if (h.startsWith('53514c69746520666f726d61742033')) return '.sqlite';
    if (h.includes('6674797061766966') || h.includes('6674797061766973')) return '.avif';
    if (h.startsWith('25504446')) return '.pdf';
    if (h.startsWith('47494638')) return '.gif';
    if (h.startsWith('424d')) return '.bmp';
    if (h.startsWith('464c5601')) return '.flv';
    if (h.startsWith('4344303031')) return '.iso';
    if (h.startsWith('474000') || h.startsWith('474001')) return '.ts';
    if (h.startsWith('49492a00') || h.startsWith('4d4d002a')) return '.tif';
    if (h.startsWith('52617221')) return '.rar';
    if (h.startsWith('4f676753')) return '.ogg';
    if (h.startsWith('664c6143')) return '.flac';
    if (h.startsWith('4d546864')) return '.mid';
    if (h.startsWith('4d5a') && h.includes('000000')) return '.exe';
    if (h.startsWith('52494646')) {
        if (bin.length >= 12) {
            const type = h.substring(16, 24);
            if (type === '57454250') return '.webp';
            if (type === '57415645') return '.wav';
            if (type === '41564920') return '.avi';
        }
        return '.riff';
    }
    if (bin.length > 262) {
        const tarMagic = String.fromCharCode(...bin.slice(257, 262));
        if (tarMagic === "ustar") return '.tar';
    }
    if (h.startsWith('000000')) {
        if (h.includes('ffffff')) return '.cmix';
        if (h.includes('667479704d3441')) return '.m4a';
        if (h.includes('66747970')) return '.mp4';
        return '.bin'; 
    }
    if (h.startsWith('494433') || h.startsWith('fffb') || h.startsWith('fff1')) return '.mp3';
    return ''; 
}
let deferredPrompt;
async function coreRestore(rawBin, pwd, sniffSource, fileName, rawFileBuf) {
    const sixHeader = parseSixHeader(fileName, sniffSource, rawFileBuf);
    const startTime = Date.now();
    const isSixHeaderValid = !!(sixHeader && sixHeader.isValid);
    const targetCksum = isSixHeaderValid ? sixHeader.cksumTarget : -1;

    let algoOrder = [1, 2, 4, 5, 3, 0]; 
    if (isSixHeaderValid) algoOrder = [sixHeader.firstAlgo, ...algoOrder.filter(a => a !== sixHeader.firstAlgo)];

    let candidates = [];
    let triedAlgoCount = 0;

    for (const mode of algoOrder) {
        if ((mode <= 2 || mode === 4) && !pwd) continue; 
        
        triedAlgoCount++;
        let currentEd = { isEd: false, isAdmin: false, usedPubKey: null, sigValid: false };
        let backupEd = edIdentity; 
        edIdentity = currentEd;

        let decrypted = null;
        try { decrypted = await tryRestore(rawBin, pwd, mode); } catch (e) {}
        edIdentity = backupEd; 

        if (!decrypted || !decrypted.length) continue;

        let score = 0;
        // æ ¸å¿ƒåˆ¤åˆ†ï¼šç®—æ³•æˆåŠŸ
        if ([1, 2, 4].includes(mode)) score += 4; // GCM/P-384/å± è§£å¯†æˆåŠŸ
        if (currentEd.sigValid) score += 2;        // Edç­¾åéªŒè¯æˆåŠŸ

        // ç‰¹å¾åˆ¤å®šï¼šGZIP
        let finalData = decrypted;
        if (decrypted.length > 2 && decrypted[0] === 0x1f && decrypted[1] === 0x8b) {
            try {
                finalData = pako.ungzip(decrypted);
                score += 0.5; // GZIPè§£å‹æˆåŠŸ
            } catch (e) { finalData = decrypted; }
        }

        // æ ¸å¿ƒåˆ¤åˆ†ï¼šæ ¡éªŒå’Œ
        const h = new Uint8Array(await window.crypto.subtle.digest('SHA-256', finalData));
        const currentCksum = ((h[16] << 8) | h[17]) >>> 0;
        if (isSixHeaderValid && currentCksum === targetCksum) score += 1;

        // å¼±ç‰¹å¾åˆ¤åˆ†
        if (getAutoExtension(finalData)) score += 0.25; // æœ‰æ‰©å±•åç‰¹å¾
        if (getAutoExtension(finalData) === '.bin') score -= 0.25;
                if (getAutoExtension(finalData) === '.riff') score -= 0.125;
        if (bufToHex(finalData.slice(0, 4)).startsWith('000000')) score += 0.125; // 0x000000å¼€å¤´ç­‰å¼±ç‰¹å¾

        candidates.push({ 
            data: finalData, 
            score: score, 
            mode: mode, 
            edState: currentEd, 
            cksum: currentCksum 
        });
        if (score >= 4) break;
    }
if (!candidates.length) return null;
    
    // 1. ä¼˜åŒ–æ’åºï¼šè¯„åˆ†é«˜è€…ä¼˜å…ˆï¼›å¹³åˆ†(0åˆ†)æ—¶ï¼Œæ˜æ–‡(Mode 5)æ’åœ¨æœ€å‰
    candidates.sort((a, b) => (b.score - a.score) || (a.mode === 5 ? -1 : (b.mode === 5 ? 1 : 0)));
    
    const best = candidates[0];
    window.lastDecMode = best.mode;
    window.lastDecScore = best.score;
    window.edIdentity = best.edState;
    window.decryptStats = { 
        usedTime: ((Date.now() - startTime) / 1000).toFixed(3),
        triedAlgoCount: triedAlgoCount 
    };

    // 2. æ ¡éªŒå’Œåˆ¤å®š
    decWarning.active = (isSixHeaderValid && targetCksum !== 0 && best.cksum !== targetCksum);
    if (decWarning.active) {
        decWarning.message = `âš ï¸ æ ¡éªŒå’Œä¸åŒ¹é… (é¢„æœŸ:${targetCksum.toString(16)} å®é™…:${best.cksum.toString(16)})`;
        
        // --- æ–°å¢ï¼šå¹¶åˆ—0åˆ†ä¸”æ ¡éªŒå¤±è´¥æ—¶å¼¹å‡º Alert ---
        if (best.score <= 0) {
            alert("âš ï¸ è¿˜åŸé¢„è­¦ï¼š\næ ¡éªŒå’Œä¸åŒ¹é…ä¸”æœªæ£€æµ‹åˆ°ä»»ä½•æœ‰æ•ˆçš„æ•°æ®ç‰¹å¾ï¼ˆè¯„åˆ† 0.000ï¼‰ã€‚\nè¯·æ£€æŸ¥å¯†é’¥æ˜¯å¦æ­£ç¡®ï¼Œæˆ–æ•°æ®æ˜¯å¦å®Œæ•´ã€‚");
        }
    }

    return best.data;
}
// æœç´¢å¹¶æ›¿æ¢ getAlgoName å‡½æ•°
function getAlgoName(m) {
    return ["CBC", "GCM", "P384", "Ed25519", "ç®¡ç†å‘˜ç­¾åçš„åŠ å¯†æ–‡ä»¶", "æ˜æ–‡"][m] || "æœªçŸ¥";
}
function dlDec() {
    if (!dData) return;
    const ext = getAutoExtension(dData);
    let name = decodeFileName || "è¿˜åŸæ–‡ä»¶";
    
    // 1. æ¸…ç†åŸæœ‰çš„ .bin æˆ– .txt åç¼€ï¼Œå¹¶æ ¹æ®è¯†åˆ«ç»“æœæ·»åŠ æ–°åç¼€
    name = name.replace(/\.(bin|txt)$/i, '');
    if (ext && !name.toLowerCase().endsWith(ext)) {
        name += ext;
    } else if (!ext && !name.includes('.')) {
        name += '.bin'; 
    }
    
    const blob = new Blob([dData]);
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; 
    a.download = name;
    
    // 2. ç»†èŠ‚å¢å¼ºï¼šå¿…é¡»æŒ‚è½½åˆ° body æ‰èƒ½ç¡®ä¿åœ¨æŸäº›ä¸¥è‹›æµè§ˆå™¨ç¯å¢ƒä¸‹è§¦å‘ä¸‹è½½
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    // 3. æ ¸å¿ƒä¿®å¤ï¼šå»¶æ—¶é‡Šæ”¾å†…å­˜ï¼Œé˜²æ­¢è¿ç»­ä¸‹è½½å¯¼è‡´å†…å­˜æº¢å‡º
    setTimeout(() => URL.revokeObjectURL(url), 1000);
}
function formatSpeed(bytesPerSec) {
    if (bytesPerSec < 1024) return bytesPerSec.toFixed(0) + " B/s";
    if (bytesPerSec < 1048576) return (bytesPerSec / 1024).toFixed(2) + " KB/s";
    return (bytesPerSec / 1048576).toFixed(2) + " MB/s";
}
let edIdentity = {isEd: false, isAdmin: false };
let decWarning = {active: false, message: "" }; // ç”¨äºåœ¨è§£å¯†æˆåŠŸä½†æœ‰ç–‘è™‘æ—¶æ˜¾ç¤ºè­¦å‘Š
function parseSixHeader(fileName, textContent, rawBuf) {
    const HEX_MAP = "å“ˆå˜¿å˜»å’•å±å§å“”å˜šå˜›å˜å˜å˜Ÿå•¸å˜¶åš·å™—";
    const scan = (str) => {
        if (!str || typeof str !== 'string') return null;
        let found = [];
        const limit = Math.min(str.length, 500);
        for (let i = 0; i < limit; i++) {
            if (HEX_MAP.includes(str[i])) {
                found.push(str[i]);
                if (found.length === 6) return found;
            }
        }
        return null;
    };
    // å—…æ¢åœ°æ–¹1ï¼šæ–‡ä»¶æµå¼€å¤´ï¼ˆé’ˆå¯¹å¯¼å…¥çš„TXTæ–‡ä»¶ï¼‰
    let bufText = "";
    if (rawBuf) {
        try { bufText = new TextDecoder().decode(new Uint8Array(rawBuf).slice(0, 100)); } catch(e){}
    }
    // ä¼˜å…ˆçº§ï¼šæ–‡ä»¶å > æ–‡ä»¶å¼€å¤´ > æ–‡æœ¬æ¡†å†…å®¹
    let chars = scan(fileName) || scan(bufText) || scan(textContent);
    if (!chars) return { isValid: false, cksumTarget: -1 };
    const idx = chars.map(c => HEX_MAP.indexOf(c));
    return {
        isValid: true,
        cksumTarget: ((idx[0] << 12) | (idx[1] << 8) | (idx[2] << 4) | idx[3]) >>> 0, 
        firstAlgo: idx[4], 
        isEncrypted: idx[5] !== 5 
    };
}
function checkEncIdentity() {
    const valInput = $('e-key');
    const msgBox = $('enc-identity-msg');
    const algoEl = document.querySelector('input[name="algo"]:checked');
    
    if (!valInput || !msgBox || !algoEl) return;
    const val = valInput.value.trim().toLowerCase();
    const algoMode = algoEl.value;

    if (!val) {msgBox.innerHTML = ""; return; }

    // P-384 æ¨¡å¼
    if (algoMode === "2") {
        if (val === ADMIN_P384_PUB_HEX.toLowerCase()) {
            msgBox.innerHTML = `<span style="color:var(--primary)">âœ… æ­£åœ¨å‘ <b>ğŸ›¡ï¸ ç®¡ç†å‘˜</b> å‘é€åŠ å¯†ä¿¡æ¯</span>`;
        } else if (val.length > 20) {
            msgBox.innerHTML = `<span style="color:var(--warn)">ğŸ‘¤ æ­£åœ¨å‘ <b>éç®¡ç†å‘˜</b> å‘é€åŠ å¯†ä¿¡æ¯</span>`;
        } else {
            msgBox.innerHTML = `<span style="color:var(--danger)">âš ï¸ è¯·è¾“å…¥æ­£ç¡®çš„ P384 å…¬é’¥</span>`;
        }
    } 
    // Ed25519 æ¨¡å¼
    else if (algoMode === "3") {
        msgBox.innerHTML = `<span style="color:var(--warn)">âœï¸ æ­£åœ¨ä¸ºæ•°æ®ç­¾åã€‚å®é™…ä¸ä¼šåŠ å¯†æ•°æ®ã€‚</span>`;
    }
    else if (algoMode === "0") {
        msgBox.innerHTML = `<span style="color:var(--danger)">âš ï¸ CBCå·²åœæ­¢æ”¯æŒï¼Œæ•°æ®éš¾ä»¥æ¢å¤ä¸”æ˜“è¢«ç¯¡æ”¹ã€‚è¯·è½¬ä¸ºGCMã€‚</span>`;}
    // å…¶ä»–æ¨¡å¼
    else {
        msgBox.innerHTML = "";
    }
}
function backupTool() {
    try {
        // 1. è·å–å½“å‰é¡µé¢çš„å®Œæ•´ HTMLï¼ˆåŸæœ‰é€»è¾‘ä¸å˜ï¼‰
        let htmlContent = document.documentElement.outerHTML;
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlContent, 'text/html');
        const clearIds = ['res-show-area', 'decode-input', 'd-txt-area', 'log'];
        clearIds.forEach(id => {
            const el = doc.getElementById(id);
            if (el) el.value = el.textContent = '';
        });
        const hideIds = ['e-result', 'd-result', 'log', 'e-file-info', 'd-file-info'];
        hideIds.forEach(id => {
            const el = doc.getElementById(id);
            if (el) el.style.display = 'none';
        });
        const finalHtml = "<!DOCTYPE html>\n" + doc.documentElement.outerHTML;
        
        // 2. åˆ›å»ºä¸‹è½½ï¼ˆæ ¸å¿ƒä¿®æ”¹ï¼šå°†aæ ‡ç­¾æŒ‚è½½åˆ°loader-screenï¼Œè€Œébodyï¼‰
        const blob = new Blob([finalHtml], {type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        
        // --- æ ¸å¿ƒä¿®æ”¹å¼€å§‹ ---
        const loaderScreen = $('loader-screen');
        // è‹¥åœ¨URLæ¨¡å¼ï¼ˆloader-screenæ˜¾ç¤ºï¼‰ï¼Œåˆ™å°†aæ ‡ç­¾æŒ‚è½½åˆ°loader-screenå†…ï¼›å¦åˆ™æŒ‚è½½åˆ°body
        const parentEl = loaderScreen && window.getComputedStyle(loaderScreen).display !== 'none' 
            ? loaderScreen 
            : document.body;
        // --- æ ¸å¿ƒä¿®æ”¹ç»“æŸ ---
        
        // æ–‡ä»¶åç”Ÿæˆï¼ˆåŸæœ‰é€»è¾‘ä¸å˜ï¼‰
        const now = new Date();
        const f = (v) => v.toString().padStart(2, '0');
        const yy = now.getFullYear().toString().slice(-2);
        const ts = `${yy}${f(now.getMonth()+1)}${f(now.getDate())}-${f(now.getHours())}${f(now.getMinutes())}${f(now.getSeconds())}`;
        a.download = `${ts}-AmbWebCrypt.html`;
        a.href = url;
        
        // æŒ‚è½½å¹¶è§¦å‘ä¸‹è½½ï¼ˆçˆ¶å…ƒç´ æ”¹ä¸ºparentElï¼‰
        parentEl.appendChild(a);
        a.click();
        
        // 3. æ¸…ç†ï¼ˆåŸæœ‰é€»è¾‘ä¸å˜ï¼‰
        setTimeout(() => {
            parentEl.removeChild(a); // åŒæ­¥ä¿®æ”¹ç§»é™¤çš„çˆ¶å…ƒç´ 
            URL.revokeObjectURL(url);
        }, 100);
        
        alert("å·¥å…·å¤‡ä»½å·²è§¦å‘ï¼æ–‡ä»¶åï¼š" + a.download);
    } catch (e) {
        alert("å¤‡ä»½å¤±è´¥: " + e.message);
    }
}
// 1. æ¨¡å¼åˆ‡æ¢å‡½æ•°ï¼šå¢åŠ å•ä½åˆ‡æ¢é€»è¾‘ï¼Œå¹¶å¤„ç†é»˜è®¤å€¼å’Œå¯é€‰çš„è·³è¿‡é‡å¤„ç†
function handleModeChange(show, valFromParam, skipReproc = false) {// å¢åŠ äº† valFromParam å’Œ skipReproc
    const valInput = $('img-val');
    const unitText = $('unit-text');
    const mode = document.querySelector('input[name="rmode"]:checked').value;

    // åŠ¨æ€æ›´æ–°å•ä½æ–‡å­—
    if (mode === 'pixel') unitText.textContent = "ä¸‡";
    else if (mode === 'short') unitText.textContent = "px"; // çŸ­è¾¹å’Œé•¿è¾¹éƒ½æ˜¾ç¤º px
    else if (mode === 'long') unitText.textContent = "px";
    else if (mode === 'orig') unitText.textContent = "%";

    let actualValueToSet = valInput.value; // é»˜è®¤ä¿ç•™å½“å‰å€¼

    // å¦‚æœé€šè¿‡å‚æ•°æ˜ç¡®æŒ‡å®šäº†å€¼ï¼Œåˆ™ä½¿ç”¨è¯¥å€¼
    if (valFromParam !== undefined && valFromParam !== null) {
        actualValueToSet = valFromParam;
    } else {// å¦åˆ™ï¼Œæ ¹æ®å½“å‰æ¨¡å¼è®¾ç½®é»˜è®¤å€¼
        if (mode === 'pixel') actualValueToSet = "5";
        else if (mode === 'short') actualValueToSet = "240";
        else if (mode === 'long') actualValueToSet = "640";
        else if (mode === 'orig') actualValueToSet = "100";
    }

    // åªæœ‰å½“å€¼å‘ç”Ÿå˜åŒ–æ—¶æ‰æ›´æ–°è¾“å…¥æ¡†
    if (valInput.value !== actualValueToSet) {
        valInput.value = actualValueToSet;
    }
    
    // åªæœ‰åœ¨æ²¡æœ‰æ˜ç¡®è¦æ±‚è·³è¿‡æ—¶æ‰è¿›è¡Œå›¾åƒé‡å¤„ç†
    if (!skipReproc) {
        reprocImg(); 
    }
}
function syncBinCheckbox() {
    const val = $('decode-input').value;
    const cb = $('is-bin');
    if (val.includes("äºŒè¿›åˆ¶")) {
        cb.checked = true;
    } else if (val.includes("æ–‡æœ¬")) {
        cb.checked = false;
    }
}
let prevPreviewUrl = null; // æ”¾åœ¨å‡½æ•°å¤–éƒ¨æˆ– script é¡¶ç«¯
let lastProcessingId = 0; // å…¨å±€å˜é‡
async function reprocImg() {
    if (!oFile || !oFile.type || !oFile.type.startsWith('image/')) return;
    $('e-file-info').style.display = 'block'; // ä¿®å¤ï¼šè°ƒæ•´å‚æ•°æ—¶å¼ºåˆ¶æ˜¾ç¤ºå®¹å™¨
    const infoBox = $('e-file-info'), processingId = ++lastProcessingId;

    if (!$('img-comp').checked) {
        try {
            eData = new Uint8Array(await oFile.arrayBuffer());
            infoBox.innerHTML = `<span class="meta-tag">åŸå§‹: ${oFile.name}</span> <span class="meta-tag">${oFile.size.toLocaleString()} B</span><br><span class="meta-tag">æœªå¤„ç†é€ä¼ </span>`;
        } catch(e) {}
        return;
    }
    // ä¸‹é¢ä¿æŒåŸé€»è¾‘ï¼Œæœªæ”¹åŠ¨
    const img = new Image(), reader = new FileReader();
    reader.onload = e => {
        img.onload = () => {
            const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d');
            let w = img.width, h = img.height, r = w / h;
            const m = document.querySelector('input[name="rmode"]:checked').value;
            let targetW = w, targetH = h, v = parseFloat($('img-val').value) || 0;
            if (m !== 'orig') {
                if (m === 'pixel') {
                    let pixelCount = v * 10000;
                    if (pixelCount > MAX_PIXELS) pixelCount = MAX_PIXELS;
                    targetW = Math.sqrt(pixelCount * r); targetH = targetW / r;
                }
                else if (m === 'short') {if (w <= h) {targetW = v; targetH = targetW / r; } else {targetH = v; targetW = targetH * r; } }
                else if (m === 'long') {if (w >= h) {targetW = v; targetH = targetW / r; } else {targetH = v; targetW = targetH * r; } }
            } else {const scale = v / 100; targetW = w * scale; targetH = h * scale; }
            canvas.width = Math.round(targetW); canvas.height = Math.round(targetH);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(async b => {
                if (processingId !== lastProcessingId || !b) return;
                eData = new Uint8Array(await b.arrayBuffer());
                if (prevPreviewUrl) URL.revokeObjectURL(prevPreviewUrl); 
                prevPreviewUrl = URL.createObjectURL(b);
                infoBox.innerHTML = `<span class="meta-tag">åŸå§‹: ${oFile.name}</span><br><span class="size-info">WebP: ${canvas.width}x${canvas.height} (${eData.length.toLocaleString()} B)</span><div style="margin-top:10px; border:1px solid #333; background:#000; text-align:center;"><img src="${prevPreviewUrl}" style="max-height:150px; max-width:100%; display:block; margin:0 auto;"></div>`;
            }, 'image/webp', (parseInt($('img-q').value) || 30) / 100);
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(oFile);
}
    // æ–‡ä»¶åç”Ÿæˆï¼šæ”¯æŒå‰ç¼€
    function getFullFN(ext, prefix = "") {
        const now = new Date();
        const f = (v) => v.toString().padStart(2, '0');
        const ts = `${now.getFullYear().toString().slice(-2)}${f(now.getMonth()+1)}${f(now.getDate())}-${f(now.getHours())}${f(now.getMinutes())}${f(now.getSeconds())}`;
        const mainName = `AmbWebCrypt-${VER}-${ts}`;
        return prefix ? `${prefix}-${mainName}.${ext}` : `${mainName}.${ext}`;
    }
let decodeRawText = ""; 
async function handleFile(fileOrInput, mode) {
    let f = (fileOrInput instanceof File) ? fileOrInput : fileOrInput.files[0];
    if (!f) return;
    if (mode === 'encode') {
        oFile = f; $('e-file-info').style.display = 'block';
        if (f.type.startsWith('image/') && $('img-comp').checked) reprocImg();
        else {
            eData = new Uint8Array(await f.arrayBuffer());
            $('e-file-info').innerHTML = `<span class="meta-tag">è½½å…¥: ${f.name} (${f.size.toLocaleString()} B)</span>`;
        }
    } else {
        decodeFileName = f.name; const buf = await f.arrayBuffer(); decodeRawBuffer = buf;
        // ä¸‰ç‚¹é‡‡æ ·ï¼šå¼€å¤´ã€ä¸­é—´ã€ç»“å°¾
        const view = new Uint8Array(buf), sampleLen = 200;
        const positions = [0, Math.floor(buf.byteLength/2), Math.max(0, buf.byteLength - sampleLen)];
        let match = 0, total = 0;
        positions.forEach(pos => {
            try {
                const text = new TextDecoder().decode(view.slice(pos, pos + sampleLen));
                for(let c of text) { if(c.trim()) { total++; if(C2B[c] !== undefined) match++; } }
            } catch(e){}
        });
        const isText = total > 0 && (match / total) > 0.3;
        $('is-bin').checked = !isText;
        $('decode-input').value = `[å·²è½½å…¥ (${isText?'æ–‡æœ¬':'äºŒè¿›åˆ¶'}) æ–‡ä»¶: ${f.name}]`;
        $('d-file-info').style.display = 'block';
        $('d-file-info').innerHTML = `<span class="meta-tag">è½½å…¥: ${f.name} (${f.size.toLocaleString()} B)</span>`;
        syncBinCheckbox();
    }
}
const ADMIN_ED_PUB_HEX = "310cba5a40091f292e7e48cd1527bd80789bbaac0a922438ff9676b8ebf3febe";
// P-384 å¯†é’¥ç”Ÿæˆå‡½æ•°
async function generateP384Keys(forceGenerate = false) {
    const privKeyDisplay = $('p384-priv-key-display');
    const pubKeyDisplay = $('p384-pub-key-display');
    const idBox = $('p384-identity-info'); // P-384 ä¸“ç”¨çš„èº«ä»½æç¤ºæ¡†

    // æ›´ç²¾ç¡®åœ°æ£€æŸ¥ P-384 å¯†é’¥æ˜¯å¦å·²ç”Ÿæˆ (é€šè¿‡æ£€æŸ¥è¾“å…¥æ¡†çš„å€¼æ˜¯å¦ä¸ºé»˜è®¤å ä½ç¬¦)
    const hasKeys = (privKeyDisplay.value !== 'å°šæœªç”Ÿæˆ...' && pubKeyDisplay.value !== 'å°šæœªç”Ÿæˆ...');

    if (hasKeys && !forceGenerate) {
        if (!confirm("æ£€æµ‹åˆ° P-384 å¯†é’¥å·²ç”Ÿæˆã€‚åˆ·æ–°å°†ä¸¢å¤±å½“å‰å¯†é’¥ï¼Œç¡®å®šè¦é‡æ–°ç”Ÿæˆå—ï¼Ÿ")) {
            return; // ç”¨æˆ·å–æ¶ˆï¼Œä¸æ‰§è¡Œç”Ÿæˆ
        }
    }
    
    // å‡†å¤‡ç”Ÿæˆï¼Œæ¸…ç©ºæ˜¾ç¤ºå¹¶æ›´æ–°çŠ¶æ€
    idBox.innerHTML = "âŒ› æ­£åœ¨ç”Ÿæˆ P-384 å¯†é’¥...";
    privKeyDisplay.value = 'å°šæœªç”Ÿæˆ...'; 
    pubKeyDisplay.value = 'å°šæœªç”Ÿæˆ...';

    try {
        const algo = {name: "ECDH", namedCurve: "P-384" };
        const kp = await window.crypto.subtle.generateKey(algo, true, ["deriveKey"]);
        const pub = await window.crypto.subtle.exportKey("raw", kp.publicKey);
        const priv = await window.crypto.subtle.exportKey("pkcs8", kp.privateKey);

        privKeyDisplay.value = bufToHex(priv);
        pubKeyDisplay.value = bufToHex(pub);
        idBox.innerHTML = " <b class='guest-mark'> ğŸ‘¤ P-384 å¯†é’¥å·²ç”Ÿæˆ </b> "; // P-384 æ²¡æœ‰ç®¡ç†å‘˜èº«ä»½çš„æ¦‚å¿µ
    } catch (e) {
        alert("P-384 å¯†é’¥ç”Ÿæˆå¤±è´¥: " + e.message); 
        idBox.innerHTML = "P-384 å¯†é’¥ç”Ÿæˆå¤±è´¥";
        privKeyDisplay.value = 'å°šæœªç”Ÿæˆ...'; // å¤±è´¥æ—¶é‡ç½®
        pubKeyDisplay.value = 'å°šæœªç”Ÿæˆ...';
    }
}// Ed25519 å¯†é’¥ç”Ÿæˆå‡½æ•°
async function generateEd25519Keys(forceGenerate = false) {
    const privKeyDisplay = $('ed25519-priv-key-display');
    const pubKeyDisplay = $('ed25519-pub-key-display');
    const idBox = $('ed25519-identity-info'); // Ed25519 ä¸“ç”¨çš„èº«ä»½æç¤ºæ¡†

    // æ›´ç²¾ç¡®åœ°æ£€æŸ¥ Ed25519 å¯†é’¥æ˜¯å¦å·²ç”Ÿæˆ (é€šè¿‡æ£€æŸ¥è¾“å…¥æ¡†çš„å€¼æ˜¯å¦ä¸ºé»˜è®¤å ä½ç¬¦)
    const hasKeys = (privKeyDisplay.value !== 'å°šæœªç”Ÿæˆ...' && pubKeyDisplay.value !== 'å°šæœªç”Ÿæˆ...');

    if (hasKeys && !forceGenerate) {
        if (!confirm("æ£€æµ‹åˆ° Ed25519 å¯†é’¥å·²ç”Ÿæˆã€‚åˆ·æ–°å°†ä¸¢å¤±å½“å‰å¯†é’¥ï¼Œç¡®å®šè¦é‡æ–°ç”Ÿæˆå—ï¼Ÿ")) {
            return; // ç”¨æˆ·å–æ¶ˆï¼Œä¸æ‰§è¡Œç”Ÿæˆ
        }
    }

    // å‡†å¤‡ç”Ÿæˆï¼Œæ¸…ç©ºæ˜¾ç¤ºå¹¶æ›´æ–°çŠ¶æ€
    idBox.innerHTML = "âŒ› æ­£åœ¨ç”Ÿæˆ Ed25519 å¯†é’¥...";
    privKeyDisplay.value = 'å°šæœªç”Ÿæˆ...'; 
    pubKeyDisplay.value = 'å°šæœªç”Ÿæˆ...';

    try {
        const algo = {name: "Ed25519" };
        const kp = await window.crypto.subtle.generateKey(algo, true, ["sign", "verify"]);
        const pub = await window.crypto.subtle.exportKey("raw", kp.publicKey);
        const priv = await window.crypto.subtle.exportKey("pkcs8", kp.privateKey);

        const pubHex = bufToHex(pub);
        privKeyDisplay.value = bufToHex(priv);
        pubKeyDisplay.value = pubHex;

        // ç”ŸæˆæˆåŠŸåï¼Œåªæ˜¾ç¤ºâ€œEd25519 å¯†é’¥å·²ç”Ÿæˆâ€ã€‚
        // ç®¡ç†å‘˜èº«ä»½çš„åˆ¤æ–­åªåœ¨åŠ è½½æ—¶ï¼ˆswitchTabï¼‰è¿›è¡Œï¼Œå› ä¸ºç”¨æˆ·ä¸å¯èƒ½ç”Ÿæˆç®¡ç†å‘˜å¯†é’¥ã€‚
        idBox.innerHTML = " <b class='guest-mark'> ğŸ‘¤ Ed25519 å¯†é’¥å·²ç”Ÿæˆ </b> ";
    } catch (e) {
        alert("Ed25519 å¯†é’¥ç”Ÿæˆå¤±è´¥: " + e.message); 
        idBox.innerHTML = "Ed25519 å¯†é’¥ç”Ÿæˆå¤±è´¥";
        privKeyDisplay.value = 'å°šæœªç”Ÿæˆ...'; // å¤±è´¥æ—¶é‡ç½®
        pubKeyDisplay.value = 'å°šæœªç”Ÿæˆ...';
    }
}
// è¾…åŠ©å‡½æ•°ï¼šå¤„ç† Ed25519 ç§é’¥å¯¼å…¥
async function importEdPrivKey(keyStr) {
    if (keyStr.length >= 64 && /^[0-9a-fA-F]+$/.test(keyStr)) {
        const rawPriv = hexToBuf(keyStr);
        let finalPrivBuf = rawPriv;
        if (rawPriv.length === 32) {
            finalPrivBuf = new Uint8Array(48);
            finalPrivBuf.set(hexToBuf("302e020100300506032b657004220420"));
            finalPrivBuf.set(rawPriv, 16);
        }
        return await window.crypto.subtle.importKey('pkcs8', finalPrivBuf, {name: 'Ed25519' }, false, ['sign']);
    } else {
        const seed = await window.crypto.subtle.digest('SHA-256', new TextEncoder().encode(keyStr));
        const wrapped = new Uint8Array(48);
        wrapped.set(hexToBuf("302e020100300506032b657004220420")); 
        wrapped.set(new Uint8Array(seed), 16);
        return await window.crypto.subtle.importKey('pkcs8', wrapped, {name: 'Ed25519' }, false, ['sign']);
    }
}
async function doDecode() {
    const btn = $('btn-do-decode'), 
          inputArea = $('decode-input'), 
          isBinChecked = $('is-bin').checked, 
          keyStr = $('d-key').value.trim();
    
    if (!btn || !inputArea) return;
    btn.disabled = true; 
    btn.textContent = "âŒ› è¿˜åŸä¸­..."; 
    
    await new Promise(r => setTimeout(r, 50));
    
    try {
        let rawBin = null; 
        const currentVal = inputArea.value;
        const isPlaceholder = currentVal.includes("å·²è½½å…¥") && currentVal.includes("æ–‡ä»¶:");

        // --- ä¼˜åŒ–åçš„é€»è¾‘é€»è¾‘ ---
        // åªæœ‰å½“â€œå‹¾é€‰äº†BINâ€ä¸”â€œç¡®å®å­˜åœ¨ç‰©ç†æ–‡ä»¶æµâ€æ—¶ï¼Œæ‰ä½¿ç”¨åŸå§‹äºŒè¿›åˆ¶
        if (isBinChecked && decodeRawBuffer) {
            rawBin = new Uint8Array(decodeRawBuffer);
        } 
        // å¦åˆ™ï¼ˆæ²¡å‹¾é€‰BINï¼Œæˆ–è€…å‹¾é€‰äº†BINä½†æ²¡ä¼ æ–‡ä»¶åªæ˜¯ç²˜è´´äº†æ–‡å­—ï¼‰ï¼Œä¸€å¾‹å°è¯•è§£ææ±‰å­—ç¼–ç 
        else {
            // å¦‚æœæ˜¯å ä½ç¬¦ï¼Œè¯´æ˜æ–‡ä»¶æ˜¯æ‹–å…¥çš„TXTï¼Œå»è¯»æ–‡ä»¶æµè½¬å‡ºçš„æ±‰å­—ï¼›å¦åˆ™è¯»æ¡†é‡Œçš„æ–‡å­—
            let textToParse = (isPlaceholder && decodeRawBuffer) ? new TextDecoder().decode(decodeRawBuffer) : currentVal;
            let temp = new Uint8Array(textToParse.length), count = 0;
            
            for (let i = 0; i < textToParse.length; i++) {
                const b = C2B[textToParse[i]]; 
                if (b !== undefined) temp[count++] = b;
            }
            
            if (count === 0) {
                throw new Error(isBinChecked ? "æœªæ£€æµ‹åˆ°ç‰©ç†æ–‡ä»¶æµï¼Œä¸”æ–‡æœ¬æ¡†å†…æ— æœ‰æ•ˆç¼–ç " : "æ— æœ‰æ•ˆç¼–ç å­—ç¬¦");
            }
            rawBin = temp.slice(0, count);
        }
        // --- é€»è¾‘ç»“æŸ ---

        const result = await coreRestore(rawBin, keyStr, currentVal, decodeFileName, decodeRawBuffer);
        if (result) { 
            dData = result; 
            renderDec(result); 
        } else {
            throw new Error("è¿˜åŸå¤±è´¥");
        }
    } catch (e) { 
        alert("âŒ å¤±è´¥: " + e.message); 
    } finally { 
        btn.disabled = false; 
        btn.textContent = "ğŸ”“ æ‰§è¡Œè¿˜åŸ"; 
    }
}
async function tryRestore(rawBin, pwd, mode) {
    try {
        const keyEncoder = new TextEncoder();
        const data = new Uint8Array(rawBin);
        const cleanPwd = pwd ? pwd.trim() : "";

        // æ¨¡å¼ 0: CBC (æ—§ç‰ˆå…¼å®¹)
        if (mode === 0) {
            if (data.length < 16) return null;
            const iv = data.slice(0, 16), ciphertext = data.slice(16);
            const keyHash = await window.crypto.subtle.digest('SHA-256', keyEncoder.encode(pwd));
            const cryptoKey = await window.crypto.subtle.importKey('raw', keyHash, {name: 'AES-CBC'}, false, ['decrypt']);
            return new Uint8Array(await window.crypto.subtle.decrypt({name: 'AES-CBC', iv: iv}, cryptoKey, ciphertext));
        }

        // æ¨¡å¼ 1: GCM
        if (mode === 1) {
            if (data.length < 28) return null;
            const iv = data.slice(0, 12), ciphertext = data.slice(12);
            const keyHash = await window.crypto.subtle.digest('SHA-256', keyEncoder.encode(pwd));
            const cryptoKey = await window.crypto.subtle.importKey('raw', keyHash, {name: 'AES-GCM'}, false, ['decrypt']);
            return new Uint8Array(await window.crypto.subtle.decrypt({name: 'AES-GCM', iv: iv}, cryptoKey, ciphertext));
        }

        // æ¨¡å¼ 2: P384
        if (mode === 2) {
            if (data.length < 109) return null;
            const privBuf = hexToBuf(pwd);
            if (!privBuf) return null;
            const privKey = await window.crypto.subtle.importKey('pkcs8', privBuf, {name: 'ECDH', namedCurve: 'P-384'}, false, ['deriveKey']);
            const pubKey = await window.crypto.subtle.importKey('raw', data.slice(0, 97), {name: 'ECDH', namedCurve: 'P-384'}, false, []);
            const sharedKey = await window.crypto.subtle.deriveKey({name: 'ECDH', public: pubKey}, privKey, {name: 'AES-GCM', length: 256}, false, ['decrypt']);
            return new Uint8Array(await window.crypto.subtle.decrypt({name: 'AES-GCM', iv: data.slice(97, 109)}, sharedKey, data.slice(109)));
        }

        // æ¨¡å¼ 3 & 4: Ed25519 é€»è¾‘ä¿®å¤
        if (mode === 3 || mode === 4) {
            const sig = data.slice(0, 64);
            const payload = data.slice(64);
            edIdentity.isEd = true;
            edIdentity.sigValid = false;

            // ç¡®å®šéªŒè¯ç”¨çš„å…¬é’¥æ± 
            let pubKeys = [];
            if (mode === 4) {
                // æ¨¡å¼ 4ï¼šå§‹ç»ˆä¸”ä»…ç”¨ç®¡ç†å‘˜å…¬é’¥éªŒè¯ç­¾å
                pubKeys = [ADMIN_ED_PUB_HEX.toLowerCase()];
            } else {
                // æ¨¡å¼ 3ï¼šä¼˜å…ˆç”¨å¯†ç æ¡†é‡Œçš„å…¬é’¥ï¼Œæ²¡å¡«å°±è¯•ç®¡ç†å‘˜
                if (cleanPwd && cleanPwd.length >= 64) pubKeys.push(cleanPwd.toLowerCase());
                pubKeys.push(ADMIN_ED_PUB_HEX.toLowerCase());
            }

            // éªŒè¯ç­¾å
            for (let pkHex of pubKeys) {
                try {
                    const pubKeyBuf = hexToBuf(pkHex);
                    const pubKey = await window.crypto.subtle.importKey('raw', pubKeyBuf, {name: 'Ed25519'}, false, ['verify']);
                    if (await window.crypto.subtle.verify({name: 'Ed25519'}, pubKey, sig, payload)) {
                        edIdentity.sigValid = true;
                        edIdentity.usedPubKey = pkHex;
                        break;
                    }
                } catch (e) {}
            }

            // æ¨¡å¼ 4 è§£å¯† GCM éƒ¨åˆ†
            if (mode === 4) {
                if (!pwd) return null;
                const iv = payload.slice(0, 12), ciphertext = payload.slice(12);
                const keyHash = await window.crypto.subtle.digest('SHA-256', keyEncoder.encode(pwd));
                const cryptoKey = await window.crypto.subtle.importKey('raw', keyHash, {name: 'AES-GCM'}, false, ['decrypt']);
                return new Uint8Array(await window.crypto.subtle.decrypt({name: 'AES-GCM', iv: iv}, cryptoKey, ciphertext));
            }

            return payload; // æ¨¡å¼ 3 ç›´æ¥è¿”å›
        }

        if (mode === 5) return data;
        return null;
    } catch (e) { return null; }
}
window.onload = async () => {
    const p = new URLSearchParams(window.location.search);
    const setVal = (id, val) => {if(val && $(id)) $(id).value = val; };
    
    const generalPwd = p.get('pwd'), enPwd = p.get('enpwd'), dePwd = p.get('depwd');
    const gzipVal = p.get('gzip'), webpqVal = p.get('webpq'), ptVal = p.get('webpt'), prVal = p.get('webpr'), targetUrl = p.get('URL'); 
    
    if (generalPwd) {setVal('e-key', generalPwd); setVal('d-key', generalPwd); }
    if (enPwd) setVal('e-key', enPwd); if (dePwd) setVal('d-key', dePwd);
    if (gzipVal !== null) {const gz = $('gzip-enable'); if(gz) gz.checked = (gzipVal === 't' || gzipVal === '1'); }
    if (webpqVal) setVal('img-q', webpqVal);
    if (prVal) {setVal('img-val', prVal); if ($('img-comp').checked) reprocImg(); }
    if (ptVal) {
        const ptMap = {"1": "pixel", "2": "short", "3": "long", "4": "orig" };
        const mode = ptMap[ptVal];
        const r = document.querySelector(`input[name="rmode"][value="${mode}"]`);
        if (r) {r.checked = true; handleModeChange(true, null, !!prVal); }
    }

    if (targetUrl) {
        const loader = $('loader-screen');
        const bodyChildren = document.body.children;
        for (let i = 0; i < bodyChildren.length; i++) {
            if (bodyChildren[i].id !== 'loader-screen' && bodyChildren[i].id !== 'drop-hint') {
                bodyChildren[i].style.display = 'none';
            }
        }
        if (loader) loader.style.display = 'block';
        
        const s1Status = $('step1-status'), s1Fill = $('step1-fill'), s1Stats = $('step1-stats'), progCont = $('progress-container');
        const s2Status = $('step2-status'), s2Fill = $('step2-fill');
        const s3Status = $('step3-status'), manualDlBtn = $('manual-dl-btn');
        
        try {
            const response = await fetch(targetUrl);
            if (!response.ok) throw new Error(`ä¸‹è½½å¤±è´¥: ${response.status}`);
            
            const total = parseInt(response.headers.get('content-length'), 10);
            if (!isNaN(total)) progCont.style.display = 'block';
            
            const reader = response.body.getReader();
            let loaded = 0, chunks = [], startTime = Date.now();
            
            while(true) {
                const {done, value} = await reader.read();
                if (done) break; chunks.push(value); loaded += value.length;
                const elapsed = (Date.now() - startTime) / 1000;
                const speed = loaded / elapsed;
                if (!isNaN(total)) {
                    const percent = Math.round((loaded / total) * 100);
                    s1Fill.style.width = percent + "%";
                    s1Stats.innerText = `${percent}% | ${formatSpeed(speed)} | å‰©ä½™: ${formatTime((total - loaded) / speed)}`;
                } else {
                    s1Stats.innerText = `${(loaded/1024/1024).toFixed(1)}MB | ${formatSpeed(speed)}`;
                }
            }

            // æ‹¼è£…åŸå§‹äºŒè¿›åˆ¶
            const rawBin = new Uint8Array(loaded);
            let pos = 0;
            for(let chunk of chunks) { rawBin.set(chunk, pos); pos += chunk.length; }
            chunks = null;

            s1Status.innerText = "(å·²å®Œæˆ) 1.ä¸‹è½½åŸå§‹æ•°æ®æµ"; s1Status.style.color = "var(--primary)";
            s2Status.innerText = "(è¿›è¡Œä¸­) 2. è§£å¯†æ•°æ®"; s2Status.style.color = "var(--warn)";

            decodeFileName = decodeURIComponent(targetUrl.split('/').pop());

            // --- æ ¸å¿ƒä¿®å¤ï¼šå§‹ç»ˆä¿¡ä»»ä¸º BINï¼ŒsniffText ä¼ ç©ºå­—ç¬¦ä¸²å¼ºåˆ¶è·³è¿‡æ–‡å­—è¯†åˆ« ---
            const result = await coreRestore(rawBin, dePwd || generalPwd || "", "", decodeFileName, rawBin);
            
            if (result) {
                dData = result; renderDec(result); 
                s2Fill.style.width = "100%";
                s2Status.innerText = "(å·²å®Œæˆ) 2. è§£å¯†æ•°æ®"; s2Status.style.color = "var(--primary)";
                s3Status.innerText = "(å·²å®Œæˆ) 3. è§¦å‘ä¸‹è½½"; s3Status.style.color = "var(--primary)";
                manualDlBtn.disabled = false;
                manualDlBtn.style.background = "var(--primary)"; manualDlBtn.style.color = "#000";
                dlDec(); 
            } else throw new Error("è¿˜åŸå¤±è´¥ï¼šç»“æœæ— æ•ˆ");
        } catch (e) {
            s1Status.innerText = "(å¤±è´¥) " + e.message; s1Status.style.color = "var(--danger)";
            s2Status.innerText = "(ç»ˆæ­¢) æ— æ³•å¤„ç†æ•°æ®";
        }
    }
};
async function doEncode() {
    const btn = $('btn-do-encode'), encodeText = $('encode-text'), gzipEnable = $('gzip-enable'), algoEl = document.querySelector('input[name="algo"]:checked'), eKey = $('e-key'), eStats = $('e-stats'), resShowArea = $('res-show-area'), eResult = $('e-result');
    if (!btn || !encodeText) return;
    btn.disabled = true; btn.textContent = "âŒ› å¤„ç†ä¸­...";
    const encodeStartTime = Date.now();
    await new Promise(r => setTimeout(r, 50));
    try {
        const txt = encodeText.value.trim(), algoMode = algoEl.value, keyStr = eKey.value.trim();
        const oldH = parseSixHeader("", txt, eData) || { isValid: false, firstAlgo: -1 }; // å…œåº•é»˜è®¤å€¼
        // åˆ¤å®šâ€œå±â€æ¨¡å¼ï¼šAlgo 3 ç­¾åï¼Œä¸”è¾“å…¥å†…å®¹å·²ç»æ˜¯ Algo 1 åŠ å¯†
        const isSigningGCM = (oldH.isValid && oldH.firstAlgo === 1 && algoMode === "3");
        let processedBin = (eData && eData.length > 0) ? eData : (isSigningGCM ? new Uint8Array([...(txt.includes("ï¼Œ")?txt.split("ï¼Œ")[1]:txt)].filter(c => MAP.includes(c)).map(c => C2B[c])) : new TextEncoder().encode(txt));
        if (!processedBin || processedBin.length === 0) throw new Error("å†…å®¹ä¸ºç©º");
        const cksum = await CryptoUtils.getShaChecksum(processedBin);
        let finalBin = processedBin, featFlags = 0;
        if (gzipEnable.checked && !isSigningGCM) {
            try { const gzipped = pako.gzip(processedBin); if (gzipped.length < processedBin.length) { finalBin = gzipped; featFlags |= 0x02; } } catch (e) {}
        }
        if (algoMode === "3") {
            if(!keyStr) throw new Error("ç­¾åéœ€è¦ç§é’¥");
            featFlags |= 0x01; const privKey = await importEdPrivKey(keyStr);
            const sig = await window.crypto.subtle.sign({name: 'Ed25519' }, privKey, finalBin);
            const combined = new Uint8Array(64 + finalBin.length); combined.set(new Uint8Array(sig)); combined.set(finalBin, 64);
            finalBin = combined;
        } else if (keyStr) {
            featFlags |= 0x01; const keyEnc = new TextEncoder(), keyHash = await window.crypto.subtle.digest('SHA-256', keyEnc.encode(keyStr));
            let encrypted, combined;
            if (algoMode === "0") {
                const iv = crypto.getRandomValues(new Uint8Array(16)), key = await crypto.subtle.importKey('raw', keyHash, 'AES-CBC', false, ['encrypt']);
                encrypted = await crypto.subtle.encrypt({name:'AES-CBC', iv}, key, finalBin);
                combined = new Uint8Array(16 + encrypted.byteLength); combined.set(iv); combined.set(new Uint8Array(encrypted), 16);
            } else if (algoMode === "1") {
                const iv = crypto.getRandomValues(new Uint8Array(12)), key = await crypto.subtle.importKey('raw', keyHash, 'AES-GCM', false, ['encrypt']);
                encrypted = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, finalBin);
                combined = new Uint8Array(12 + encrypted.byteLength); combined.set(iv); combined.set(new Uint8Array(encrypted), 12);
            } else if (algoMode === "2") {
                const ephKp = await crypto.subtle.generateKey({name:'ECDH', namedCurve:'P-384'}, true, ['deriveKey']), remotePub = await crypto.subtle.importKey('raw', hexToBuf(keyStr), {name:'ECDH', namedCurve:'P-384'}, false, []);
                const shared = await crypto.subtle.deriveKey({name:'ECDH', public:remotePub}, ephKp.privateKey, {name:'AES-GCM', length:256}, false, ['encrypt']);
                const iv = crypto.getRandomValues(new Uint8Array(12)), ephPub = await crypto.subtle.exportKey('raw', ephKp.publicKey);
                encrypted = await crypto.subtle.encrypt({name:'AES-GCM', iv}, shared, finalBin);
                combined = new Uint8Array(ephPub.byteLength + 12 + encrypted.byteLength); combined.set(new Uint8Array(ephPub)); combined.set(iv, ephPub.byteLength); combined.set(new Uint8Array(encrypted), ephPub.byteLength+12);
            }
            finalBin = combined;
        }
        window.resBin = finalBin; isEncDataReady = true;
        let finalAlgo = isSigningGCM ? 4 : parseInt(algoMode);
        let h = HEX_MAP[(cksum>>12)&0xF] + HEX_MAP[(cksum>>8)&0xF] + HEX_MAP[(cksum>>4)&0xF] + HEX_MAP[cksum&0xF] + HEX_MAP[finalAlgo] + HEX_MAP[featFlags];
        window.resHeader = h;
        window.resTxt = finalBin.length > PLIM ? `${h}ï¼Œ[è§„æ¨¡è¾ƒå¤§ï¼ˆ${finalBin.length.toLocaleString()} Bï¼‰ï¼Œå·²ç¦ç”¨é¢„è§ˆ]` : `${h}ï¼Œ${Array.from(finalBin).map(b => B2C[b]).join('')}`;
        eStats.innerHTML = `è§„æ¨¡: ${finalBin.length.toLocaleString()} B | ç®—æ³•: ${getAlgoName(finalAlgo)} | ç”¨æ—¶: ${((Date.now()-encodeStartTime)/1000).toFixed(3)}s`;
        resShowArea.value = window.resTxt; eResult.style.display = "block";
    } catch (e) { alert(`âŒ ç¼–ç å¤±è´¥ï¼š${e.message}`); }
    finally { btn.disabled = false; btn.textContent = "ğŸš€ æ‰§è¡Œç¼–ç "; }
}
// æœç´¢å¹¶æ›¿æ¢æ•´ä¸ª dlRes å‡½æ•°
function dlRes(t) {
    if (!isEncDataReady || !window.resBin || window.resBin.length === 0) {
        alert("âŒ æ— æœ‰æ•ˆåŠ å¯†æ•°æ®ï¼Œè¯·å…ˆç‚¹å‡»ã€æ‰§è¡Œç¼–ç ã€‘");
        return;
    }
    try {
        let blob;
        if (t === 'txt') {
            // æ ¸å¿ƒä¿®å¤ï¼šç›´æ¥å°†æ•°ç»„äº¤ç»™ Blobï¼Œä¸è¦ä½¿ç”¨ .join('')ï¼Œé˜²æ­¢å†…å­˜çˆ†è¡¨
            const chunks = [window.resHeader, "ï¼Œ"];
            for (let i = 0; i < window.resBin.length; i++) {
                chunks.push(B2C[window.resBin[i]] || B2C[0]);
            }
            blob = new Blob(chunks, {type: 'text/plain;charset=utf-8' });
        } else {
            blob = new Blob([window.resBin], {type: 'application/octet-stream' });
        }

        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const safeHeader = (window.resHeader || "data").replace(/[\\/:*?"<>|]/g, "_");
        a.download = getFullFN(t, t === 'bin' ? safeHeader : "");
        a.href = url;
        document.body.appendChild(a);
        a.click();

        setTimeout(() => {
            if (document.body.contains(a)) document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 1500);
    } catch (e) {
        alert(`âŒ ä¸‹è½½å¤±è´¥ï¼šå†…å­˜ä¸è¶³æˆ–æ•°æ®è¿‡å¤§`);
    }
}
function clearAll(m) {
    if (m === 'encode') {
        $('encode-text').value = '';
        $('e-file-info').innerHTML = '';
        $('e-result').style.display = 'none';
        if($('enc-identity-msg')) $('enc-identity-msg').innerHTML = ''; // æ¸…ç©ºåŠ å¯†èº«ä»½
        const eInput = $('encode-file-input');
        if (eInput) eInput.value = '';
        if (prevPreviewUrl) { URL.revokeObjectURL(prevPreviewUrl); prevPreviewUrl = null; }
        eData = null; oFile = null;
    } else {
        $('decode-input').value = '';
        $('d-file-info').innerHTML = '';
        $('d-result').style.display = 'none';
        // --- æ–°å¢ï¼šæ¸…ç©ºæ‰€æœ‰è¿˜åŸç›¸å…³çš„æ ‡è¯†å’Œé¢„è­¦ ---
        if($('dec-identity-msg')) $('dec-identity-msg').innerHTML = '';
        if($('loader-identity')) $('loader-identity').innerHTML = '';
        if($('dec-warning-msg')) $('dec-warning-msg').style.display = 'none';
        if($('loader-warning-msg')) $('loader-warning-msg').style.display = 'none';
        edIdentity = {isEd: false, isAdmin: false };
        decWarning = {active: false, message: "" };
        // ---------------------------------------
        const dInput = document.querySelector('#decode-tab input[type="file"]');
        if (dInput) dInput.value = '';
        if (currentPreviewUrl) URL.revokeObjectURL(currentPreviewUrl);
        decodeRawBuffer = null; decodeRawText = ""; dData = null;
    }
    hideLog();
}
// å…¨å±€æ ‡è®°ï¼šé¿å…é‡å¤ç»‘å®šäº‹ä»¶
let isEncodeBtnBinded = false;
// 1. DOMåŠ è½½å®Œæˆåç»‘å®šæŒ‰é’®ç‚¹å‡»äº‹ä»¶ï¼ˆç¡®ä¿èƒ½æ‰¾åˆ°æŒ‰é’®å…ƒç´ ï¼‰
document.addEventListener('DOMContentLoaded', () => {
    const encodeBtn = $('btn-do-encode');
    const encodeText = $('encode-text');
    const eResult = $('e-result');
    // ä»…ç»‘å®šä¸€æ¬¡äº‹ä»¶ï¼Œé˜²æ­¢é‡å¤è§¦å‘
    if (encodeBtn && !isEncodeBtnBinded) {
        encodeBtn.addEventListener('click', () => {
            // è°ƒç”¨ç¼–ç é€»è¾‘å‰ï¼Œå…ˆç¡®è®¤æ ¸å¿ƒå…ƒç´ å­˜åœ¨
            if (!encodeText || !eResult) {
                alert("âŒ é¡µé¢å…ƒç´ åŠ è½½ä¸å®Œæ•´ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•");
                return;
            }
            doEncode();
        });
        isEncodeBtnBinded = true;
    }
});
function switchTab(tabName) {
    // 1. åˆ‡æ¢æŒ‰é’®çŠ¶æ€
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
        // è‡ªåŠ¨åŒ¹é…å½“å‰ç‚¹å‡»æˆ–æŒ‡å®šçš„æ ‡ç­¾å
        if (btn.getAttribute('onclick').includes(`'${tabName}'`)) {
            btn.classList.add('active');
        }
    });

    // 2. åˆ‡æ¢é¢æ¿æ˜¾ç¤º
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    const targetTab = $(tabName + '-tab');
    if (targetTab) targetTab.classList.add('active');

    // 3. è¾…åŠ©äº¤äº’
    hideLog();
    window.scrollTo(0, 0); // åˆ‡æ¢æ—¶å›åˆ°é¡¶éƒ¨ï¼Œæ–¹ä¾¿æ‰‹æœºæ“ä½œ

    // 4. å¯†é’¥ç”Ÿæˆé¡µé¢çš„ç‰¹æ®Šé€»è¾‘
    if (tabName === 'keygen') {
        const p384Priv = $('p384-priv-key-display');
        const edPub = $('ed25519-pub-key-display');
        const p384IdBox = $('p384-identity-info');
        const edIdBox = $('ed25519-identity-info');

        // æ£€æŸ¥æ˜¯å¦å·²æœ‰å¯†é’¥ (åˆ¤æ–­é•¿åº¦æ˜¯å¦ç¬¦åˆ Hex æ ¼å¼)
        const p384Exist = p384Priv && p384Priv.value.length > 20 && !p384Priv.value.includes('å°šæœª');
        const edExist = edPub && edPub.value.length > 20 && !edPub.value.includes('å°šæœª');

        // ä»…åœ¨å®Œå…¨æ²¡æœ‰å¯†é’¥æ—¶æ‰è‡ªåŠ¨ç”Ÿæˆï¼Œé˜²æ­¢åˆ‡å›æ¥æ—¶è¦†ç›–æ‰ç”¨æˆ·æ­£åœ¨ä½¿ç”¨çš„å¯†é’¥
        if (!p384Exist) {
            generateP384Keys(true); 
        } else {
            p384IdBox.innerHTML = " <b class='guest-mark' style='color:var(--primary)'> ğŸ‘¤ P-384 å¯†é’¥å·²å°±ç»ª </b> ";
        }

        if (!edExist) {
            generateEd25519Keys(true); 
        } else {edIdBox.innerHTML = " <b class='guest-mark' style='color:var(--primary)'> ğŸ‘¤ Ed25519 å¯†é’¥å·²å°±ç»ª </b> ";
        }
    }
}
function showLog(m, type="danger"){
    const l=$('log'); l.textContent=m; l.style.display='block'; 
    l.style.color = type === "warn" ? "var(--warn)" : "var(--danger)";
    alert(m);
}
// æ›¿æ¢åŸæœ‰çš„ copyKey, copyRes, fallbackCopy
async function copyTo(text, msg = "å·²å¤åˆ¶") {
    try {
        if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(text);
        } else {
            const area = document.createElement('textarea');
            area.value = text;
            document.body.appendChild(area);
            area.select();
            document.execCommand('copy');
            document.body.removeChild(area);
        }
        alert(msg);
    } catch (e) {
        alert("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©å¤åˆ¶");
    }
}

// å¯¹åº”çš„ copyRes ç®€åŒ–ç‰ˆ
async function copyRes() {
    if (!window.resBin) return alert("æ²¡æœ‰å†…å®¹å¯å¤åˆ¶");
    if (window.resBin.length > 2000000) return alert("æ•°æ®è¿‡å¤§ï¼Œè¯·ä½¿ç”¨ã€ä¸‹è½½TXTã€‘");
    const chunks = [window.resHeader, "ï¼Œ"];
    for (let i = 0; i < window.resBin.length; i++) chunks.push(B2C[window.resBin[i]]);
    copyTo(chunks.join(''), "å…¨é‡ç¼–ç å·²å¤åˆ¶");
}

// å¯¹åº”çš„ copyKey ç®€åŒ–ç‰ˆ
function copyKey(id) {
    const val = $(id).value;
    if (val && !val.includes("å°šæœª")) copyTo(val, "å¯†é’¥å·²å¤åˆ¶");
}
function hideLog(){$('log').style.display='none'; }
    // æ‹–æ‹½é€»è¾‘
    const dh = $('drop-hint'); let dc = 0;
    document.addEventListener('dragenter', e=>{e.preventDefault(); dc++; dh.classList.add('show'); });
    document.addEventListener('dragleave', e=>{e.preventDefault(); dc--; if(dc<=0) dh.classList.remove('show'); });
    document.addEventListener('dragover', e=>e.preventDefault());
    document.addEventListener('drop', e=>{
        e.preventDefault(); dh.classList.remove('show'); dc=0;
        handleFile(e.dataTransfer.files[0], $('encode-tab').classList.contains('active') ? 'encode' : 'decode');
    });
function renderDec(bin) {
    const loaderScreen = $('loader-screen');
    const isLoaderActive = loaderScreen && window.getComputedStyle(loaderScreen).display !== 'none';
    const warningBox = $(isLoaderActive ? 'loader-warning-msg' : 'dec-warning-msg');

    // 1. æ ¡éªŒå’Œè­¦å‘Šå¤„ç†
    if (warningBox) {
        warningBox.style.display = decWarning.active ? "block" : "none";
        warningBox.innerHTML = decWarning.active ? decWarning.message : "";
    }
    if (currentPreviewUrl) { URL.revokeObjectURL(currentPreviewUrl); currentPreviewUrl = null; }
    if (!bin) return;

    // 2. æ˜ å°„å¯¹åº”çš„ UI å®¹å™¨
    const ui = isLoaderActive ? {
        result: $('loader-result'), 
        stats: $('loader-stats'), 
        identity: $('loader-identity'),
        preImg: $('loader-preview-img'), 
        imgCont: $('loader-img'),
        preTxt: $('loader-preview-txt'), 
        txtArea: $('loader-txt-area')
    } : {
        result: $('d-result'), 
        stats: $('d-stats'), 
        identity: $('dec-identity-msg'),
        preImg: $('d-preview-img'), 
        imgCont: $('d-img'),
        preTxt: $('d-preview-txt'), 
        txtArea: $('d-txt-area')
    };

    if (ui.result) ui.result.style.display = 'block';
    const ext = getAutoExtension(bin).toLowerCase();
    
    // 3. ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤º
    const rawScore = window.lastDecScore || 0;
    const statsInfo = window.decryptStats || {};
    if (ui.stats) {
        ui.stats.textContent = `${bin.length.toLocaleString()} B` + (ext ? ` [${ext.toUpperCase().slice(1)}]` : ' [RAW]') +
                               ` | ç®—æ³•:${getAlgoName(window.lastDecMode)}` +
                               ` | è¯„åˆ†: ${rawScore.toFixed(3)}` + 
                               ` | ç”¨æ—¶: ${statsInfo.usedTime || '0.00'}s`;
    }

    // 4. ã€æ ¸å¿ƒä¿®å¤ã€‘è¯»å–å…¨å±€è§£å¯†èº«ä»½ window.edIdentity
    const activeEd = window.edIdentity || { isEd: false };
    if (ui.identity) {
        if (activeEd.isEd) {
            ui.identity.style.display = "block";
            if (activeEd.sigValid) {
                // åˆ¤æ–­æ˜¯å¦ä¸ºç®¡ç†å‘˜
                const isAdmin = (activeEd.usedPubKey === ADMIN_ED_PUB_HEX.toLowerCase());
                
                if (isAdmin) {
                    ui.identity.innerHTML = `<span style="color:var(--primary)">âœ… è¯¥ä¿¡æ¯ç”± <b>ğŸ›¡ï¸ ç®¡ç†å‘˜</b> ç­¾åå‘å¸ƒ</span>`;
                } else {
                    // ä»…åœ¨ URL ä¸‹è½½é¡µæ¨¡å¼ ä¸” éç®¡ç†å‘˜æ—¶ï¼Œæ˜¾ç¤ºå‰16ä½å…¬é’¥
                    let pubSuffix = (isLoaderActive && activeEd.usedPubKey) 
                        ? `<br><small style="color:#888; font-size:0.75rem;">éªŒè¯å…¬é’¥: ${activeEd.usedPubKey.slice(0, 16)}...</small>` 
                        : "";
                    ui.identity.innerHTML = `<span style="color:var(--warn)">âœ… è¯¥ä¿¡æ¯ç”± <b>ğŸ‘¤ éç®¡ç†å‘˜</b> ç­¾åå‘å¸ƒ</span>${pubSuffix}`;
                }
            } else {
                ui.identity.innerHTML = `<span style="color:var(--danger)">âŒ <b>èº«ä»½ç­¾åéªŒè¯å¤±è´¥</b> (å†…å®¹å¯èƒ½è¢«ç¯¡æ”¹)</span>`;
            }
        } else {
            ui.identity.style.display = "none";
        }
    }

    // 5. åª’ä½“/æ–‡æœ¬é¢„è§ˆé€»è¾‘
    const isImage = ['.png', '.jpg', '.gif', '.webp', '.avif', '.tif', '.bmp'].includes(ext);
    const isMedia = ['.mp4', '.mkv', '.ogg', '.webm', '.mp3', '.m4a', '.wav', '.flac', '.ts', '.flv', '.avi', '.mid'].includes(ext);

    if (isImage || isMedia) {
        if (ui.preTxt) ui.preTxt.style.display = 'none';
        currentPreviewUrl = URL.createObjectURL(new Blob([bin]));
        if (ui.imgCont) {
            ui.imgCont.innerHTML = isImage ? 
                `<img src="${currentPreviewUrl}" style="max-width:100%; border:1px solid #333; margin-top:10px;">` :
                `<video src="${currentPreviewUrl}" controls style="max-width:100%; margin-top:10px; background:#000;"></video>`;
        }
        if (ui.preImg) ui.preImg.style.display = 'block';
    } else {
        if (ui.preImg) ui.preImg.style.display = 'none';
        try {
            const text = new TextDecoder("utf-8", { fatal: false }).decode(bin.slice(0, 100000));
            if (ui.txtArea) ui.txtArea.value = text + (bin.length > 100000 ? "\n\n(å·²è¾¾åˆ°é¢„è§ˆä¸Šé™ï¼Œè¯·ä¸‹è½½æ–‡ä»¶)" : "");
            if (ui.preTxt) ui.preTxt.style.display = 'block';
        } catch (e) { 
            if (ui.txtArea) ui.txtArea.value = "[äºŒè¿›åˆ¶æˆ–ä¸æ”¯æŒé¢„è§ˆçš„æ ¼å¼]"; 
            if (ui.preTxt) ui.preTxt.style.display = 'block';
        }
    }
}
</script>
<script>if('serviceWorker' in navigator){navigator.serviceWorker.register('sw.js')}</script>

</body></html>